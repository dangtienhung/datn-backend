import Order from '../models/order.model.js';
import { orderValidate } from '../validates/order.validate.js';

export const orderController = {
  /* create */
  create: async (req, res) => {
    try {
      const body = req.body;
      /* validate */
      const { error } = orderValidate.validate(body, { abortEarly: false });
      if (error) {
        return res.status(400).json({ error: error.message });
      }
      const items = body.items;
      /* t√≠nh t·ªïng ti·ªÅn c·ªßa ƒë∆°n h√†ng ng∆∞·ªùi d√πng v·ª´a ƒë·∫∑t */
      let total = 0;
      items.forEach((item) => {
        total += item.quantity * item.price;
        /* n·∫øu m√† s·∫£n ph·∫©m c√≥ topping */
        if (item.toppings.length > 0 && item.toppings) {
          item.toppings.forEach((topping) => {
            total += topping.price;
          });
        }
      });
      /* ki·ªÉm tra xem ƒë√£ c√≥ order n√†o ch∆∞a */
      const orderExits = await Order.findOne({ user: body.user, status: 'pending' });
      if (!orderExits) {
        const priceShipping = Number(body.priceShipping) || 0;
        /* t·∫°o ƒë∆°n h√†ng m·ªõi */
        const order = new Order({
          ...body,
          total: total + priceShipping,
          priceShipping: body.priceShipping,
          is_active: true,
        });
        /* l∆∞u ƒë∆°n h√†ng m·ªõi */
        const orderNew = await order.save();
        if (!orderNew) {
          return res.status(400).json({ error: 'create order failed' });
        }
        return res.status(200).json({ message: 'create order successfully', order: orderNew });
      }
      /* khi ƒë√£ t·ªìn t·∫°i order ƒë√≥ r·ªìi */
      for (let item of orderExits.items) {
        /* ki·ªÉm tra xem s·∫£n ph·∫©m ƒë√≥ ƒë√£ t·ªìn t·∫°i trong order ch∆∞a */
        const productExits = body.items.find((product) => {
          return item.product.toString() === product.product.toString();
        });
        if (productExits) {
          /* n·∫øu s·∫£n ph·∫©m t·ªìn t·∫°i r·ªìi th√¨ check xem c√≥ tr√πng size kh√¥ng th√¨ l√†m nh∆∞ n√†o */
          if (item.size._id === productExits.size._id) {
            /* n·∫øu tr√πng size th√¨ c·ªông th√™m s·ªë l∆∞·ª£ng v√†o */
            item.quantity += productExits.quantity;
          } else {
            /* n·∫øu kh√¥ng tr√πng size th√¨ th√™m s·∫£n ph·∫©m ƒë√≥ v√†o order */
            orderExits.items.push({
              image: productExits.image,
              product: productExits.product,
              quantity: productExits.quantity,
              price: productExits.price,
              toppings: productExits.toppings,
              size: productExits.size,
            });
          }
          /* save l·∫°i s·∫£n ph·∫©m */
          console.log(
            'üöÄ ~ file: order.controller.js:113 ~ create: ~ orderExits.items',
            orderExits.items
          );
          return res.status(200).json({ message: 'create order successfully', order: orderExits });
        } else {
          /* n·∫øu ch∆∞a t·ªìn t·∫°i th√¨ th√™m s·∫£n ph·∫©m ƒë√≥ v√†o order */
          orderExits.items.push({
            image: item.image,
            product: item.product,
            quantity: item.quantity,
            price: item.price,
            toppings: item.toppings,
            size: item.size,
          });
        }
        // const orderUpdate = await orderExits.save();
        // if (!orderUpdate) {
        //   return res.status(400).json({ error: 'update order failed' });
        // }
        // return res.status(200).json({ message: 'update order successfully', order: orderUpdate });
      }
      return res.status(200).json({ message: 'update order successfully' });
      /* ki·ªÉm tra xem s·∫£n ph·∫©m ƒë√£ c√≥ trong order ch∆∞a */
    } catch (error) {
      return res.status(500).json({ error: error.message });
    }
  },
  /* get all order */
  getAll: async (req, res) => {
    try {
      const { _page = 1, _limit = 10, q } = req.query;
      const options = {
        page: _page,
        limit: _limit,
        sort: { createdAt: -1 },
        populate: [
          {
            path: 'user',
            select: '-password -products -order',
            populate: { path: 'role', select: '-users' },
          },
          { path: 'items.product' },
        ],
      };
      const query = q ? { name: { $regex: q, $options: 'i' } } : {};
      const orders = await Order.paginate(query, options);
      if (!orders) {
        return res.status(400).json({ error: 'get all order failed' });
      }
      return res.status(200).json({ ...orders });
    } catch (error) {
      return res.status(500).json({ error: error.message });
    }
  },

  /* get order by id */
  getById: async (req, res) => {
    try {
      const { id } = req.params;
      const order = await Order.findById(id).populate([
        {
          path: 'user',
          select: '-password -products -order',
          populate: { path: 'role', select: '-users' },
        },
        { path: 'items.product' },
      ]);
      if (!order) {
        return res.status(400).json({ error: 'get order by id failed' });
      }
      return res.status(200).json({ order });
    } catch (error) {
      return res.status(500).json({ error: error.message });
    }
  },

  /* c·∫≠p nh·∫≠t tr·∫°ng th√°i ƒë∆°n h√†ng */
  updateStatus: async (id, status) => {
    try {
      const updateState = await Order.findByIdAndUpdate(
        id,
        { status: status },
        { new: true }
      ).populate([
        {
          path: 'user',
          select: '-password -products -order',
          populate: { path: 'role', select: '-users' },
        },
        { path: 'items.product' },
      ]);
      if (!updateState) {
        return res.status(400).json({ error: 'update status order failed' });
      }
      return updateState;
    } catch (error) {
      return res.status(500).json({ error: error.message });
    }
  },

  /* c·∫≠p nh·∫≠t tr·∫°ng th√°i ƒë∆°n h√†ng th√†nh confirmed */
  confirmOrder: async (req, res) => {
    try {
      const { id } = req.params;
      const orderConfirm = await orderController.updateStatus(id, 'confirmed');
      if (!orderConfirm) {
        return res.status(400).json({ error: 'confirm order failed' });
      }
      return res.status(200).json({ message: 'confirm order successfully', order: orderConfirm });
    } catch (error) {
      return res.status(500).json({ error: error.message });
    }
  },

  /* c·∫≠p nh·∫≠t tr·∫°ng th√°i ƒë∆°n h√†ng th√†nh delivered */
  deliveredOrder: async (req, res) => {
    try {
      const { id } = req.params;
      const orderDelivered = await orderController.updateStatus(id, 'delivered');
      if (!orderDelivered) {
        return res.status(400).json({ error: 'delivered order failed' });
      }
      return res
        .status(200)
        .json({ message: 'delivered order successfully', order: orderDelivered });
    } catch (error) {
      return res.status(500).json({ error: error.message });
    }
  },

  /* c·∫≠p nh·∫≠t tr·∫°ng th√°i ƒë∆°n h√†ng th√†nh canceled */
  canceledOrder: async (req, res) => {
    try {
      const { id } = req.params;
      const orderCanceled = await orderController.updateStatus(id, 'canceled');
      if (!orderCanceled) {
        return res.status(400).json({ error: 'canceled order failed' });
      }
      return res.status(200).json({ message: 'canceled order successfully', order: orderCanceled });
    } catch (error) {
      return res.status(500).json({ error: error.message });
    }
  },

  /* c·∫≠p nh·∫≠t tr·∫°ng th√°i ƒë∆°n h√†ng th√†nh done */
  doneOrder: async (req, res) => {
    try {
      const { id } = req.params;
      const orderDone = await orderController.updateStatus(id, 'done');
      if (!orderDone) {
        return res.status(400).json({ error: 'done order failed' });
      }
      return res.status(200).json({ message: 'done order successfully', order: orderDone });
    } catch (error) {
      return res.status(500).json({ error: error.message });
    }
  },

  /* c·∫≠p nh·∫≠t tr·∫°ng th√°i ƒë∆°n h√†ng v·ªÅ penƒëing */
  pendingOrder: async (req, res) => {
    try {
      const { id } = req.params;
      const orderPending = await orderController.updateStatus(id, 'pending');
      if (!orderPending) {
        return res.status(400).json({ error: 'pending order failed' });
      }
      return res.status(200).json({ message: 'pending order successfully', order: orderPending });
    } catch (error) {
      return res.status(500).json({ error: error.message });
    }
  },

  /* x√≥a ƒë∆°n h√†ng */
  deleteOrder: async (req, res) => {
    try {
      const { id } = req.params;
      const orderDelete = await Order.findByIdAndDelete(id);
      if (!orderDelete) {
        return res.status(400).json({ error: 'delete order failed' });
      }
    } catch (error) {
      return res.status(500).json({ error: error.message });
    }
  },

  /* l·∫•y ra c√°c ƒë∆°n h√†ng theo tr·∫°ng th√°i */
  getOrderByStatus: async (req, res, status) => {
    try {
      const { _page = 1, _limit = 10, q } = req.query;
      /* c√°c ƒëi·ªÅu ki·ªán c·∫ßn */
      const options = {
        page: _page,
        limit: _limit,
        sort: { createdAt: -1 },
        populate: [
          { path: 'user', select: '-password -products -order' },
          { path: 'items.product' },
        ],
      };
      /* ch·ª©c nƒÉng t√¨m ki·∫øm ƒë∆°n h√†ng */
      let query = { status };
      if (q) {
        console.log('üöÄ ~ file: order.controller.js:265 ~ getOrderByStatus: ~ q:', q);
        const searchQuery = {
          $or: [
            { name: { $regex: q, $options: 'i' } },
            { status: { $regex: q, $options: 'i' } },
            { address: { $regex: q, $options: 'i' } },
            { 'user.username': { $regex: q, $options: 'i' } },
            { 'user.email': { $regex: q, $options: 'i' } },
            { 'user.phone': { $regex: q, $options: 'i' } },
            { 'items.product.name': { $regex: q, $options: 'i' } },
          ],
        };
        query = { $and: [searchQuery, query] };
      }
      const orders = await Order.paginate(query, options);
      if (!orders) {
        return res.status(400).json({ error: `get all order ${status} failed` });
      }
      return res.status(200).json({ ...orders });
    } catch (error) {
      return res.status(500).json({ error: error.message });
    }
  },

  /* l·∫•y ra t·∫•t c·∫£ c√°c ƒë∆°n h√†ng c√≥ tr·∫°ng th√°i l√† confirm */
  getAllOrderConfirmed: async (req, res) => {
    try {
      return orderController.getOrderByStatus(req, res, 'confirmed');
    } catch (error) {
      return res.status(500).json({ error: error.message });
    }
  },

  /* l·∫•y ra t·∫•t c·∫£ c√°c ƒë∆°n h√†ng c√≥ tr·∫°ng th√°i l√† delivered */
  getAllOrderDelivered: async (req, res) => {
    try {
      return orderController.getOrderByStatus(req, res, 'delivered');
    } catch (error) {
      return res.status(500).json({ error: error.message });
    }
  },

  /* l·∫•y ra t·∫•t c·∫£ c√°c ƒë∆°n h√†ng c√≥ tr·∫°ng th√°i l√† done */
  getAllOrderDone: async (req, res) => {
    try {
      return orderController.getOrderByStatus(req, res, 'done');
    } catch (error) {
      return res.status(500).json({ error: error.message });
    }
  },

  /* l·∫•y ra t·∫•t c·∫£ c√°c ƒë∆°n h√†ng c√≥ tr·∫°ng th√°i l√† canceled */
  getAllOrderCanceled: async (req, res) => {
    try {
      return orderController.getOrderByStatus(req, res, 'canceled');
    } catch (error) {
      return res.status(500).json({ error: error.message });
    }
  },

  /* l·∫•y ra t·∫•t c·∫£ c√°c ƒë∆°n h√†ng c√≥ tr·∫°ng th√°i l√† penƒëing */
  getAllOrderPending: async (req, res) => {
    try {
      return orderController.getOrderByStatus(req, res, 'pending');
    } catch (error) {
      return res.status(500).json({ error: error.message });
    }
  },
};
